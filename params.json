{"name":"Test-repo","tagline":"This my first repository. A test repository.","body":"# Table of Contents\r\n- [1. Introduction](#intro)\r\n    - [Introductory Example](#intro-example)\r\n  - [1.1 Requirements & Download](#requirements)\r\n- [2. Run the Application](#run-app)\r\n - [2.1 GUI (Graphical User Interface)](#gui)\r\n - [2.2 Running in Command Line](#command-line)\r\n    - [Example](#command-line-example)\r\n - [2.3 Running through the Java API](#java-api)\r\n- [3. Other Examples](#other-examples)\r\n - [3.1 ExampleTinyDirectedGraph.java](#other-examples-example1)\r\n - [3.2 ExampleTinyUndirectedGraph.java](#other-examples-example2)\r\n - [3.3 ExamplePapel.java](#other-examples-example3)\r\n- [References](#references)\r\n- [License](#license)\r\n \r\n# <a name=\"intro\"></a>1. Introduction\r\n\r\nThis is an implementation in Java of the **polarity propagation algorithm** \r\ndescribed on [[1]](#propor2012), section *\"3. The Polarity Propagation Algorithm\"*,\r\nfor classifying *words*, *multiwords* and *synsets* as `positive`, `negative` and \r\n`neutral` based on an **undirected graph**.\r\n\r\nThis implementation also allows running the algorithm described on [[2]](#epia2011),\r\nsection \"*2.3 Simple and Intuitive Polarity Propagation - Algorithm*\",\r\nfor classifying words as `positive` or `negative` based on a **direted graph**.\r\n\r\n\r\n<br/>In both algorithms, the goal is to start with a small set of *words*, *multiwords*\r\nor *synsets* manually classified, and automatically classify a bigger set of words as \r\n`positive`, `negative` or even `neutral`.\r\nThe set of words produced by these algorithms, may be useful, for example, \r\nfor building a dictionary of sentiment words for [Sentiment Analysis / Opinion Mining](http://en.wikipedia.org/wiki/Sentiment_analysis).\r\n\r\n### <a name=\"intro-example\"></a>Introductory Example \r\n\r\nThis example tries to explain the goal, the input, and output of the mentioned algorithms. \r\n\r\nSuppose that our goal is to classify a set of words as `positive`, `negative` and \r\n`neutral` with a few effort.\r\n\r\n- **First**, we can collect the words that we want to classify automatically, \r\n  together with their *synonyms* and *antonyms*. We can collect this information from\r\n  a *dictionary*, *thesaurus* or *wordnet*. \r\n\r\n  For this example, we collected a few words from online dictionaries. These words\r\n  are saved in the file [examples/01-tiny-graph-english/graph-edges-utf8.txt](examples/01-tiny-graph-english/graph-edges-utf8.txt)\r\n  and are shown on the following figure as an **undirect graph**.\r\n  In this graph, a *dashed line* represents an **antonym** and a *solid line*\r\n  represents a **synonym**. Note that this graph is a *disconnected graph*.\r\n\r\n![tiny-undirected-graph-of-english-words](docs/figures/ex01-undirected-graph-state-01.png)\r\n\r\n- **Second**, we need to manually classify a set of words.\r\n\r\n  For this example, we have classified the words **good** as `positive`, **bad** \r\n  as `negative`, and **common** as `neutral`. These words are saved on the file\r\n  [examples/01-tiny-graph-english/seed-words-utf8.csv](examples/01-tiny-graph-english/seed-words-utf8.csv)\r\n  and are shown in the following figure with a different color.\r\n\r\n![tiny-undirected-graph-of-english-words](/docs/figures/ex01-undirected-graph-state-02.png)\r\n\r\n- **Finally**, the **polarity propagation algorithm** can be applied to classify \r\nthe words not yet classified. The result of this step is shown in the following graph.\r\n\r\n![tiny-undirected-graph-of-english-words](/docs/figures/ex01-undirected-graph-state-03.png)\r\n\r\n**As result**, we got a list of words classified as `positive` (green nodes), \r\n`negative` (red nodes), `neutral` (gray nodes), as shown on the above figure. \r\nThis list of words is also available in the file [examples/01-tiny-graph-english/dic-output.csv](examples/01-tiny-graph-english/dic-output.csv).\r\n\r\nSome observations:\r\n- In some cases we can end up with words classified also as `ambiguous` \r\n(words with more than one polarity at same time) and `unknown` (words with polarity not set). \r\nThe latter happens with all nodes that are not connected to a classified node.\r\n\r\n## <a name=\"requirements\"></a>1.1 Requirements & Download\r\n\r\n### 1.1.1 Download\r\n\r\nThe binary files can be downloaded by clicking on the link `release`\r\nat the top of this page. The application run on Windows/Linux/Mac OS and so on \r\n(see the requirements in the next section).\r\n\r\n### 1.1.2 Requirements\r\n\r\nIf you downloaded the binary files you just need to have installed:\r\n- `JRE (Java Runtime Environmen) 1.6` or higher;\r\n- Or `JDK (Java Development Kit)` 1.6 or higher.\r\n\r\nIf you downloaded the source code, you also need to download and set on your project:\r\n- The `jgrapht-core-0.9.0.jar` file from http://jgrapht.org/.\r\n\r\n# <a name=\"run-app\"></a>2. Running the Application\r\n \r\nThis implementation can be run from a **gui (graphical user interface)**, \r\n**command line** and through a **Java API**. In all cases it is required as **input**:\r\n\r\n- **A set of seed items**. This is an initial set of *words*, *multiwords*, or *synsets* \r\nclassified as `positive` and `negative` (and optionally as `neutral`);\r\n- **A set of relations between items**. This is set of **synonyms** and **antonymys** \r\n(optional) *words*, *multiwords* or *synsets* that we want to classify. These \r\nrelations are used to build a graph.\r\n\r\nThe implementation will **output**:\r\n- A list of items, each one classified as `positive`, `negative`, `neutral`, `ambiguous` \r\n(item with more than one polarity), and `unknown` (item with polarity not set).\r\n\r\n## <a name=\"gui\"></a>2.1 GUI (Graphical User Interface)\r\n\r\nThe application can run from the next Graphical User Interface.\r\n\r\n![Grapical user interface](/docs/figures/gui-0.6.0.png)\r\n\r\nFor running the application, click on the button `Run Algorithm` after specifying at least:\r\n- A **seed words file** like the [examples/01-tiny-graph-english/seed-words-utf8.csv]\r\nfile.\r\n- A **graph file** like the [examples/01-tiny-graph-english/graph-edges-utf8.txt](examples/01-tiny-graph-english/graph-edges-utf8.txt)\r\nfile.\r\n \r\nFor opening the graphical user interface (GUI) double click in the `polarity-propagation-X.X.X.jar` \r\n(X.X.X stands for the number version) jar file. \r\nIf the double click didn't work on your Operating System, open a *command line/terminal* and type:\r\n\r\n```\r\njava -jar polarity-propagation-X.X.X.jar\r\n```\r\n(X.X.X must be replaced by the application version that you are trying to run)\r\n\r\n## <a name=\"command-line\"></a>2.2 Running in Command Line\r\n\r\nThe application can be run from the command line, by running:\r\n\r\n```\r\njava -jar <path-to-the-application-jar> {mandatory-options} [optional-options]\r\n```\r\n\r\n**Options:**\r\n\r\n| Option         | Type \t  | Description\r\n| -------------- | ---------- | -----------\r\n| -h             | optional   | help\r\n| -s &lt;file_name&gt; | mandatory  | Seed words file.\r\n| -g &lt;file_name&gt; | mandatory  | Graph file. Load it as an undirected graph.\r\n| -u &lt;file_name&gt; | mandatory | Same as -g\r\n| -d &lt;file_name&gt; | mandatory | Graph file. Load it as a directed graph.\r\n| -o &lt;file_name&gt; | optional   | Output file.\r\n| -e encoding    | optional   | Caracter encoding of all the files.\r\n\r\nNOTE: options -g, -u and -s are are mutually exclusive. Specify just one. \r\n\r\n### <a name=\"command-line-example\"></a>Example\r\n\r\nThis example, shows how to reproduce the previous example in the command line, to\r\nclassify a set of words as `positive`, `negative` and `neutral`. \r\n\r\n- First, we create a file with the word **good** classified as `positive`, **bad** \r\nclassified as `negative`, and the word **common** classified as `neutral`. \r\nThis file is available at [examples/01-tiny-graph-english/seed-words-utf8.csv](examples/01-tiny-graph-english/seed-words-utf8.csv) \r\nand its content is shown below:\r\n\r\n```\r\ngood,1\r\nbad,-1\r\ncommon,0\r\n```\r\n\r\n- Then, we create a file of graph edges. A sample of this file is shown below.\r\nThe full file is available at [examples/01-tiny-graph-english/graph-edges-utf8.txt](examples/01-tiny-graph-english/graph-edges-utf8.txt). \r\n\r\n```\r\ngood SYN firm\r\ngood SYN hard\r\ngood SYN informed\r\ngood SYN just\r\ngood ANT bad\r\nbad SYN bastard\r\nbad SYN bush\r\nbad SYN bush-league\r\nbad SYN crummy\r\n(...)\r\n```\r\n\r\n- Finally, we run the following command line:\r\n\r\n```\r\njava -jar polarity-propagation-0.6.0.jar -s \"examples/01-tiny-graph-english/seed-words-utf8.csv\" -g \"examples/01-tiny-graph-english/graph-edges-utf8.txt\" -e \"utf-8\" -o \"examples/01-tiny-graph-english/dic-output.csv\"\r\n```\r\n\r\nThe result of the above command is a list of words classified with their polarity.\r\nThis list of words is saved as [examples/01-tiny-graph-english/dic-output.csv](examples/01-tiny-graph-english/dic-output.csv). \r\nA sample of the **outputted csv file**, is the following:\r\n\r\n```\r\nwords,polarity,negativeCounter,neutralCounter,positiveCounter,iteration\r\ngood,+,0,0,1,0\r\ncommonsense,+,1,0,0,1\r\ncommonsensible,+,0,0,1,1\r\ncommonsensical,+,0,0,1,1\r\nfirm,+,0,0,1,1\r\nhard,+,0,0,1,1\r\n(...)\r\nwell-founded,+,0,0,3,1\r\ngroundless,-,1,0,0,1\r\nillogical,-,3,0,0,1\r\ninvalid,-,3,0,0,1\r\nirrational,-,3,0,0,1\r\n(...)\r\nweak,-,2,0,0,2\r\nfairish,+,0,0,1,2\r\nserviceable,+,0,0,1,2\r\ndeficient,-,1,0,0,2\r\ninadequate,-,1,0,0,2\r\ninsufficient,-,1,0,0,2\r\nlacking,-,1,0,0,2\r\n``` \r\n\r\n## <a name=\"java-api\"></a>2.3 Running through the Java API\r\n\r\nThe application can be called through the Java API. The previous example and previous\r\ncommand line can be reproduced by the following Java code:\r\n\r\n```java\r\n// Read the graph from a file\r\nTriplesLoader loader = new TriplesLoader();\r\nSimpleGraph<Word, LexicalRelation> initialGraph \r\n\t\t= loader.load(\r\n\t\t new File(\"examples/01-tiny-graph-english/graph-edges-utf8.txt\")\r\n\t\t, \"utf-8\");\r\n\r\n// Read the seed words from a file\r\nSeedWordsLoader seedWordsLoader = new SeedWordsLoader(); \r\nList<Word> seedWords = seedWordsLoader.load(\r\n\t\t new File(\"examples/01-tiny-graph-english/seed-words-utf8.csv\")\r\n\t\t, \"utf-8\");\r\n\r\n// Propagate the polarity from the seed words to the remaining words\r\nSimpleGraph<Word, LexicalRelation> finalGraph = \r\n\tPolarityPropagation.propagate(initialGraph, seedWords);\r\n\r\n//\tWrite the list of words to a csv file\r\nCsvOutput csv = new CsvOutput(new File(\"examples/01-tiny-graph-english/dic-output.csv\"));\r\ncsv.write(finalGraph);   \r\n```\r\n\r\n# <a name=\"other-examples\"></a>3. Other Examples\r\n\r\nThese examples shown in the next subsections run from Java code. \r\nThey are available in the package [pt.psantos.phd.polarity.propagation.examples](/src/pt/psantos/phd/polarity/propagation/examples).\r\n\r\n## <a name=\"other-examples-example1\"></a>3.1 ExampleTinyDirectedGraph.java \r\n\r\nThe [ExampleTinyDirectedGraph.java](src/pt/psantos/phd/polarity/propagation/examples/ExampleTinyDirectedGraph.java#L149)\r\nfile implements the example described in [[1]](#epia2011), on section \r\n**2.3 Intuitive and Simple Polarity Propagation - Algorithm**.\r\n\r\n![tiny-directed-graph-of-letters-epia](/docs/figures/tiny-directed-graph-of-letters-epia.png)\r\n\r\nThis example shows how to propagate the `positive` and `negative` polarity of \r\n**A** and **B** over a tiny **directed graph** of synonyms and antonymys. \r\n\r\n1. Starting with (graph shown on the *initial state*):\r\n  - A directed graph;\r\n  - `A` classified as `positive` and `B` classified as `negative`. \r\n2. Applying the propagation algorithm.\r\n3. We got the graph shown in the figure on its *final state*. In the final graph:\r\n  - `A, C, F` are classified as `positive`;\r\n  - `B, E, H, I` are classified as `negative`;\r\n  - `D, G` are classified as `ambiguous` (they are simultaneously `positive` and `negative`).\r\n\r\n## <a name=\"other-examples-example2\"></a>3.2 ExampleTinyUndirectedGraph.java\r\n\r\nThe [ExampleTinyUndirectedGraph](src/pt/psantos/phd/polarity/propagation/examples/ExampleTinyUndirectedGraph.java)\r\nfile implements the example described in [[2]](#propor2012), on section \r\n**3 The Polarity Propagation Algorithm**.\r\n\r\n![tiny-undirected-graph-of-numbers-propor](/docs/figures/tiny-undirected-graph-of-numbers-propor.png)\r\n\r\nThis example shows how to propagate the `positive`, `negative` and `neutral` \r\npolarity over a tiny **undirected graph** of synonyms. This graph is shown below. \r\n\r\n1. Starting with (graph shown on the *initial state*):\r\n  - `0, 1` and `2` classified as `positive`, `negative` and `neutral` \r\n  respectively (graph shown on the *initial state*).\r\n2. Applying the propagation algorithm.\r\n3. We got the graph shown in the figure on its *final state*. In the final graph: \r\n  - `0, 6, 8, 9, 10` are classified as `positive`;\r\n  - `1, 4` are classified as `negative`;\r\n  - `2, 3` are classified as `neutral`;\r\n  - `5, 7` are classified as `ambiguous` (they are simultaneously positive and negative);\r\n  - `11, 12` end up with `no polarity`.\r\n\r\n## <a name=\"other-examples-example3\"></a>3.3 ExamplePapel.java\r\n\r\nThis example shows how to create an **undirect graph of synonyms** for Portuguese \r\nadjectives from [PAPEL](http://www.linguateca.pt/PAPEL/).\r\n\r\nThe full Java code to reproduce this is example is available on\r\n[ExamplePapel](src/pt/psantos/phd/polarity/propagation/examples/ExamplePapel.java).\r\n\r\n<!--\r\n# Tips\r\n\r\n- Generally, the smaller the distance between a non seed words and the closest seed \r\nword greater the probability of that word being correctly classified. \r\n-->\r\n\r\n# <a name=\"references\"></a>References\r\n\r\n1. <a name=\"propor2012\"></a>Santos, A. P., Gonçalo Oliveira, H., Ramos, C., & Marques, N. C. (2012). \r\n[A Bootstrapping Algorithm for Learning the Polarity of Words](http://www.psantos.com.pt/files/trabalhos-academicos/publicacoes/2012PROPOR_bootstrappingAlgorithm.pdf). \r\nIn Proceedings of 10th International Conference - Computational Processing of the Portuguese \r\nLanguage (PROPOR 2012), volume 7243 of LNCS, pp. 229-234. Coimbra, Portugal. \r\nSpringer.\r\n\r\n2. <a name=\"epia2011\"></a>Santos, A. P., Ramos, C., & Marques, N. C. (2011). \r\n[Determining the Polarity of Words through a Common Online Dictionary](http://www.psantos.com.pt/files/trabalhos-academicos/publicacoes/2011EPIA_polarityOfWordsThroughCommonDictionary.pdf). \r\nIn Proceedings of 15th Portuguese Conference on Artificial on Artificial intelligence \r\n(EPIA 2011), volume 7026 of LNCS, pp. 649-663. Lisbon, Portugal. Springer.\r\n\r\n\r\n# <a name=\"license\"></a>License\r\n- [Licence](LICENSE)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}